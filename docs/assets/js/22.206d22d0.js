(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{532:function(_,v,t){"use strict";t.r(v);var a=t(6),e=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[_._v("#")]),_._v(" 性能优化")]),_._v(" "),t("h2",{attrs:{id:"_1-减少http请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-减少http请求"}},[_._v("#")]),_._v(" 1. 减少"),t("code",[_._v("HTTP")]),_._v("请求")]),_._v(" "),t("p",[_._v("一个完整的"),t("code",[_._v("http")]),_._v("请求需要经过"),t("code",[_._v("DNS")]),_._v("寻址，"),t("code",[_._v("TCP")]),_._v("握手，浏览器发出请求，服务器接收请求，服务器解析请求，服务器回应，浏览器接收回应等过程，所以减少"),t("code",[_._v("HTTP")]),_._v("请求能很好的降低资源消耗。")]),_._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://raw.githubusercontent.com/aaaaaAndy/picture/main/images/20210129135946.png",alt:"1611023809804_5D5239C5-2ABD-49C7-BAF6-DF56D240C905"}}),_._v(" "),t("p",[_._v("以上是一个"),t("code",[_._v("http")]),_._v("请求，下面是其名词解释")]),_._v(" "),t("ul",[t("li",[t("p",[t("code",[_._v("Queueing")]),_._v(": 在请求队列中的时间。")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("Stalled")]),_._v(": 从"),t("code",[_._v("TCP")]),_._v(" 连接建立完成，到真正可以传输数据之间的时间差，此时间包括代理协商时间。")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("Proxy negotiation")]),_._v(": 与代理服务器连接进行协商所花费的时间。")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("DNS Lookup")]),_._v(": 执行DNS查找所花费的时间，页面上的每个不同的域都需要进行"),t("code",[_._v("DNS")]),_._v("查找。")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("Initial Connection / Connecting")]),_._v(": 建立连接所花费的时间，包括"),t("code",[_._v("TCP")]),_._v("握手/重试和协商"),t("code",[_._v("SSL")]),_._v("。")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("SSL")]),_._v(": 完成"),t("code",[_._v("SSL")]),_._v("握手所花费的时间。")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("Request sent")]),_._v(": 发出网络请求所花费的时间，通常为一毫秒的时间。")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("Waiting(TFFB)")]),_._v(": "),t("code",[_._v("TFFB")]),_._v(" 是发出页面请求到接收到应答数据第一个字节的时间。")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("Content Download")]),_._v(": 接收响应数据所花费的时间。")])])]),_._v(" "),t("p",[_._v("所以可以看出，发出一个"),t("code",[_._v("http")]),_._v("请求，不仅仅是简单地将数据拿回来，而是要花费时间在各个过程上，这也就是为什么要"),t("code",[_._v("http")]),_._v("请求次数，将小图合成一张大图请求的原因了。")]),_._v(" "),t("h2",{attrs:{id:"_2-使用http2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-使用http2"}},[_._v("#")]),_._v(" 2. 使用"),t("code",[_._v("HTTP2")])]),_._v(" "),t("p",[t("code",[_._v("http2")]),_._v("相对于"),t("code",[_._v("http1.1")]),_._v("有以下几个有点")]),_._v(" "),t("ol",[t("li",[_._v("二进制分帧：解析速度快；")]),_._v(" "),t("li",[_._v("多路复用：HTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求。在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。 多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。")]),_._v(" "),t("li",[_._v("头部压缩：浏览器会缓存相同的头部，每次只发送不同的头部字段，这样就大大减少了头部字段占用的空间。")]),_._v(" "),t("li",[_._v("服务器推送："),t("code",[_._v("http2")]),_._v("可以针对一个请求返回多个响应，无需客户端明确地请求。")])]),_._v(" "),t("h2",{attrs:{id:"_3-服务端渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-服务端渲染"}},[_._v("#")]),_._v(" 3. 服务端渲染")]),_._v(" "),t("p",[_._v("有服务端拼接"),t("code",[_._v("HTML")]),_._v("文件，返回给客户端，客户端只需要解析"),t("code",[_._v("HTML")]),_._v("文件即可。这样做，能更快地呈现页面，尤其针对首屏渲染。")]),_._v(" "),t("h2",{attrs:{id:"_4-静态资源使用cdn"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-静态资源使用cdn"}},[_._v("#")]),_._v(" 4. 静态资源使用"),t("code",[_._v("CDN")])]),_._v(" "),t("p",[_._v("内容分发网络（"),t("code",[_._v("CDN")]),_._v("）是一组分布在不同地理位置上的"),t("code",[_._v("web")]),_._v("服务器， 我们知道，当服务器离用户越远，延迟越高，所以"),t("code",[_._v("CDN")]),_._v("就解决了这一问题，让用户里服务器尽可能的近一些。")]),_._v(" "),t("h2",{attrs:{id:"_5-css文件放头部-javascript文件放尾部"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-css文件放头部-javascript文件放尾部"}},[_._v("#")]),_._v(" 5. "),t("code",[_._v("CSS")]),_._v("文件放头部，"),t("code",[_._v("JavaScript")]),_._v("文件放尾部")]),_._v(" "),t("p",[_._v("所有放在 head 标签里的 CSS 和 JS 文件都会堵塞渲染（CSS 不会阻塞 DOM 解析）。如果这些 CSS 和 JS 需要加载和解析很久的话，那么页面就空白了。所以 JS 文件要放在底部，等 HTML 解析完了再加载 JS 文件。")]),_._v(" "),t("p",[_._v("那为什么 CSS 文件还要放在头部呢？")]),_._v(" "),t("p",[_._v("因为先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了。")]),_._v(" "),t("p",[_._v("另外，JS 文件也不是不可以放在头部，只要给 script 标签加上 defer 属性就可以了，异步下载，延迟执行。")]),_._v(" "),t("h2",{attrs:{id:"_6-使用字体iconfont替换图片"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-使用字体iconfont替换图片"}},[_._v("#")]),_._v(" 6. 使用字体"),t("code",[_._v("iconfont")]),_._v("替换图片")]),_._v(" "),t("p",[_._v("一来可以压缩图片体积，而来可以将多个图片的请求转换为一个"),t("code",[_._v("ttf")]),_._v("字体文件的请求。")]),_._v(" "),t("h2",{attrs:{id:"_7-善用缓存-不重复加载资源"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-善用缓存-不重复加载资源"}},[_._v("#")]),_._v(" 7. 善用缓存，不重复加载资源")]),_._v(" "),t("p",[_._v("为了避免用户每次访问网站都得请求文件，我们可以通过添加 "),t("code",[_._v("Expires")]),_._v(" 或 "),t("code",[_._v("max-age")]),_._v(" 来控制这一行为。"),t("code",[_._v("Expires")]),_._v(" 设置了一个时间，只要在这个时间之前，浏览器都不会请求文件，而是直接使用缓存。而 "),t("code",[_._v("max-age")]),_._v(" 是一个相对时间，建议使用 "),t("code",[_._v("max-age")]),_._v("代替 Expires 。")]),_._v(" "),t("h2",{attrs:{id:"_8-压缩文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-压缩文件"}},[_._v("#")]),_._v(" 8. 压缩文件")]),_._v(" "),t("p",[_._v("压缩文件可以减少文件下载时间，让用户体验性更好。")]),_._v(" "),t("p",[_._v("得益于 webpack 和 node 的发展，现在压缩文件已经非常方便了。")]),_._v(" "),t("p",[_._v("在 webpack 可以使用如下插件进行压缩：")]),_._v(" "),t("ul",[t("li",[_._v("JavaScript：UglifyPlugin")]),_._v(" "),t("li",[_._v("CSS ：MiniCssExtractPlugin")]),_._v(" "),t("li",[_._v("HTML：HtmlWebpackPlugin")])]),_._v(" "),t("p",[_._v("其实，我们还可以做得更好。那就是使用 gzip 压缩。可以通过向 HTTP 请求头中的 Accept-Encoding 头添加 gzip 标识来开启这一功能。当然，服务器也得支持这一功能。")]),_._v(" "),t("p",[_._v("gzip 是目前最流行和最有效的压缩方法。举个例子，我用 Vue 开发的项目构建后生成的 app.js 文件大小为 1.4MB，使用 gzip 压缩后只有 573KB，体积减少了将近 60%。")]),_._v(" "),t("h2",{attrs:{id:"_9-图片优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-图片优化"}},[_._v("#")]),_._v(" 9. 图片优化")]),_._v(" "),t("h3",{attrs:{id:"_9-1-图片延迟加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-图片延迟加载"}},[_._v("#")]),_._v(" 9.1 图片延迟加载")]),_._v(" "),t("p",[_._v("在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。对于图片很多的网站来说，一次性加载全部图片，会对用户体验造成很大的影响，所以需要使用图片延迟加载。")]),_._v(" "),t("h3",{attrs:{id:"_9-2-响应式图片"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-响应式图片"}},[_._v("#")]),_._v(" 9.2 响应式图片")]),_._v(" "),t("p",[_._v("响应式图片的优点是浏览器能够根据屏幕大小自动加载合适的图片。")]),_._v(" "),t("h3",{attrs:{id:"_9-3-压缩图片"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-压缩图片"}},[_._v("#")]),_._v(" 9.3 压缩图片")]),_._v(" "),t("p",[_._v("例如 JPG 格式的图片，100% 的质量和 90% 质量的通常看不出来区别，尤其是用来当背景图的时候。我经常用 PS 切背景图时， 将图片切成 JPG 格式，并且将它压缩到 60% 的质量，基本上看不出来区别。")]),_._v(" "),t("p",[_._v("压缩方法有两种，一是通过 webpack 插件 "),t("code",[_._v("image-webpack-loader")]),_._v("，二是通过在线网站进行压缩。")]),_._v(" "),t("h3",{attrs:{id:"_9-4-使用webp格式的图片"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-4-使用webp格式的图片"}},[_._v("#")]),_._v(" 9.4 使用"),t("code",[_._v("webp")]),_._v("格式的图片")]),_._v(" "),t("p",[_._v("WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。")]),_._v(" "),t("h2",{attrs:{id:"_10-使用webpack按需加载代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-使用webpack按需加载代码"}},[_._v("#")]),_._v(" 10. 使用"),t("code",[_._v("webpack")]),_._v("按需加载代码")]),_._v(" "),t("p",[_._v("懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。")]),_._v(" "),t("h2",{attrs:{id:"_11-减少浏览器重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-减少浏览器重绘"}},[_._v("#")]),_._v(" 11. 减少浏览器重绘")]),_._v(" "),t("p",[_._v("使用 transform 和 opacity 属性更改来实现动画")]),_._v(" "),t("p",[t("strong",[_._v("重排")])]),_._v(" "),t("p",[_._v("当改变 DOM 元素位置或大小时，会导致浏览器重新生成渲染树，这个过程叫重排。")]),_._v(" "),t("p",[t("strong",[_._v("重绘")])]),_._v(" "),t("p",[_._v("当重新生成渲染树后，就要将渲染树每个节点绘制到屏幕，这个过程叫重绘。不是所有的动作都会导致重排，例如改变字体颜色，只会导致重绘。记住，重排会导致重绘，重绘不会导致重排 。")]),_._v(" "),t("p",[_._v("重排和重绘这两个操作都是非常昂贵的，因为 JavaScript 引擎线程与 GUI 渲染线程是互斥，它们同时只能一个在工作。")]),_._v(" "),t("p",[_._v("什么操作会导致重排？")]),_._v(" "),t("ul",[t("li",[_._v("添加或删除可见的 DOM 元素")]),_._v(" "),t("li",[_._v("元素位置改变")]),_._v(" "),t("li",[_._v("元素尺寸改变")]),_._v(" "),t("li",[_._v("内容改变")]),_._v(" "),t("li",[_._v("浏览器窗口尺寸改变")])]),_._v(" "),t("p",[_._v("如何减少重排重绘？")]),_._v(" "),t("ul",[t("li",[_._v("用 JavaScript 修改样式时，最好不要直接写样式，而是替换 class 来改变样式。")]),_._v(" "),t("li",[_._v("如果要对 DOM 元素执行一系列操作，可以将 DOM 元素脱离文档流，修改完成后，再将它带回文档。推荐使用隐藏元素（display:none）或文档碎片（DocumentFragement），都能很好的实现这个方案。")])]),_._v(" "),t("h2",{attrs:{id:"_12-使用requestanimationframe"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-使用requestanimationframe"}},[_._v("#")]),_._v(" 12. 使用"),t("code",[_._v("requestAnimationFrame")])]),_._v(" "),t("p",[_._v("从第 16 点我们可以知道，大多数设备屏幕刷新率为 60 次/秒，也就是说每一帧的平均时间为 16.66 毫秒。在使用 JavaScript 实现动画效果的时候，最好的情况就是每次代码都是在帧的开头开始执行。而保证 JavaScript 在帧开始时运行的唯一方式是使用 "),t("code",[_._v("requestAnimationFrame")]),_._v("。")]),_._v(" "),t("h2",{attrs:{id:"_13-使用web-workers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-使用web-workers"}},[_._v("#")]),_._v(" 13. 使用"),t("code",[_._v("Web Workers")])]),_._v(" "),t("p",[_._v("Web Worker 使用其他工作线程从而独立于主线程之外，它可以执行任务而不干扰用户界面。一个 worker 可以将消息发送到创建它的 JavaScript 代码, 通过将消息发送到该代码指定的事件处理程序（反之亦然）。")]),_._v(" "),t("p",[_._v("Web Worker 适用于那些处理纯数据，或者与浏览器 UI 无关的长时间运行脚本。")]),_._v(" "),t("h2",{attrs:{id:"_14-使用位操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-使用位操作"}},[_._v("#")]),_._v(" 14. 使用位操作")]),_._v(" "),t("p",[_._v("JavaScript 中的数字都使用 IEEE-754 标准以 64 位格式存储。但是在位操作中，数字被转换为有符号的 32 位格式。即使需要转换，位操作也比其他数学运算和布尔操作快得多。")]),_._v(" "),t("h2",{attrs:{id:"性能优化-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#性能优化-2"}},[_._v("#")]),_._v(" 性能优化")]),_._v(" "),t("h3",{attrs:{id:"_1-前端如何进行seo优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-前端如何进行seo优化"}},[_._v("#")]),_._v(" 1. 前端如何进行SEO优化")]),_._v(" "),t("ul",[t("li",[_._v("合理的 title，description，keywords 搜索引擎对这三项的权重逐个减小，title 值强调重点即可，重要的关键词出现不要超过两次")]),_._v(" "),t("li",[_._v("不同页面的 title 要有所不同，description 把页面内容高度概括，长度合适，不同页面的 description 应有所不同")]),_._v(" "),t("li",[_._v("语义化 HTML 代码，有利于搜索引擎理解网页")]),_._v(" "),t("li",[_._v("重要的内容放在前面，搜索引擎对抓取长度有限制，要保证重要内容一定会被抓取")]),_._v(" "),t("li",[_._v("重要的内容不要用 js 输出，爬虫不会执行 js 获取内容")]),_._v(" "),t("li",[_._v("尽量少用 iframe ，搜索引擎不会抓取 iframe中的内容")]),_._v(" "),t("li",[_._v("非装饰图片必须加 alt")]),_._v(" "),t("li",[_._v("提高网站速度，网站相应速度是搜索引擎排序的一个重要指标")])]),_._v(" "),t("ol",{attrs:{start:"7"}},[t("li",[_._v("如何优化自己的代码")])]),_._v(" "),t("h3",{attrs:{id:"_2-web开发中会话跟踪的方法有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-web开发中会话跟踪的方法有哪些"}},[_._v("#")]),_._v(" 2.  web开发中会话跟踪的方法有哪些")]),_._v(" "),t("h4",{attrs:{id:"_2-1-cookie"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-cookie"}},[_._v("#")]),_._v(" 2.1 Cookie")]),_._v(" "),t("p",[_._v("​\t\t中文译为小甜饼，由Netscape公司发明，是最常用的跟踪用户会话的方式。Cookies是一种由服务器发送给客户端的片段信息，存储在客户端的内存或者硬盘上，在客户随后对该服务器的请求中发回它。其实主要就是把服务器为客户端分配的session ID保存在Cookies中，每次发送请求时把Cookies附加到请求对象中一起发过去，服务器得到这个唯一的session ID，从而可以唯一的标识一个客户端。")]),_._v(" "),t("h4",{attrs:{id:"_2-2-隐藏表单域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-隐藏表单域"}},[_._v("#")]),_._v(" 2.2 隐藏表单域")]),_._v(" "),t("p",[_._v('​\t\tHTML 表单中可以含有如下的条目：<input type="hidden" name="session" value=“a1234">。是一种最简单的方式，将字段隐藏在HTML表单中，但不在客户端显示。比如在第一张页面中输入用户名和密码登陆，服务器生成响应返回第二张页面。当第二张页面提交时可能仍然需要知道来自第一张页面中的用户名。那么就可以通过隐藏表单域来实现这一连续的过程。当第一张页面提交后，服务器端作出响应返回第二张页面，此页面中用隐藏域记录了来自登陆时的用户名。通俗说就是当服务器回发给客户端的响应中，就同时把用户名再次回发到客户端，用隐藏域隐藏起来，是不可见的。当第二张页面提交时，此隐藏域中的用户名一并随表单提交。这样服务器就仍然可以判断此用户是否与以前的用户相同。于是，再次处理完结果后继续将响应回发给客户端，且此响应中也仍然包含了用户名，在客户端中仍然用隐藏域将这一信息隐藏。这样就完成了一个连续请求的动作，但是对于用户，这是不可见的。')]),_._v(" "),t("h4",{attrs:{id:"_2-3-url重写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-url重写"}},[_._v("#")]),_._v(" 2.3 URL重写")]),_._v(" "),t("p",[_._v("​\t\t采用这种方式时，客户程序在每个URL的尾部添加一些额外数据（键值对）。这些数据标识当前的会话，服务器将这个标识符与它存储的用户相关数据关联起来。 URL重写是比较不错的会话跟踪解决方案，即使浏览器不支持 cookie 或在用户禁用 cookie 的情况下，这种方案也能够工作。")]),_._v(" "),t("h4",{attrs:{id:"_2-4-ssl安全套接字层"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-ssl安全套接字层"}},[_._v("#")]),_._v(" 2.4 SSL安全套接字层")]),_._v(" "),t("p",[_._v("​\t\t安全套接字层，是一种运行在TCP/IP之上和像HTTP这种应用层协议之下的加密技术。SSL是在HTTPS协议中使用的加密技术。SSL可以让采用SSL的服务器认证采用SSL的客户端，并且在客户端和服务器之间保持一种加密了连接，在建立了加密连接的过程中，客户端和服务器都可以产生一种名为“会话密钥”的东西，它是一种用于加密和解密的对称密钥。基于HTTPS协议的服务器可以使用这个客户端的对称密钥来建立会话.")]),_._v(" "),t("h3",{attrs:{id:"_8-如果一个页面很卡-如何去定位问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-如果一个页面很卡-如何去定位问题"}},[_._v("#")]),_._v(" 8. 如果一个页面很卡，如何去定位问题")])])}),[],!1,null,null,null);v.default=e.exports}}]);