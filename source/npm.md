



## npm

### 1. 剖析package.json

![20201111160224](https://raw.githubusercontent.com/aaaaaAndy/picture/main/images/20210129140046.jpg)

在 `Node.js` 中，模块是一个库或框架，也是一个 `Node.js` 项目。`Node.js` 项目遵循模块化的架构，当我们创建了一个 `Node.js` 项目，意味着创建了一个模块，这个模块必须有一个描述文件，即 `package.json`

### 2. npm命令

以`jollychic`包为例：

- 查看包是否被占用: `npm view jollychic`
- 查看包版本：`npm view jollychic version`
- 升级修订版本号：`npm version patch`
- 升级次版本号：`npm version minor`
- 升级主版本号：`npm version major`
- 列出有哪些还没有升级到最新版本的依赖：`npm outdated`
- 升级所有的红色依赖：`npm update`

### 3. npm版本管理

`npm包` 中的模块版本都需要遵循 `SemVer`规范——由 `Github` 起草的一个具有指导意义的，统一的版本号表示规则。实际上就是 `Semantic Version`（语义化版本）的缩写。

1. 标准版本

`SemVer`规范的标准版本号采用 `X.Y.Z` 的格式，其中 X、Y 和 Z 为非负的整数，且禁止在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须以数值来递增。

- 主版本号(`major`)：当你做了不兼容的API 修改
- 次版本号(`minor`)：当你做了向下兼容的功能性新增
- 修订号(`patch`)：当你做了向下兼容的问题修正。

例如：`1.9.1 -> 1.10.0 -> 1.11.0`

2. 先行版本

当某个版本改动比较大、并非稳定而且可能无法满足预期的兼容性需求时，你可能要先发布一个先行版本。

先行版本号可以加到“主版本号.次版本号.修订号”的后面，先加上一个连接号再加上一连串以句点分隔的标识符和版本编译信息。

- 内部版本(`alpha`):
- 公测版本(`beta`):
- 正式版本的候选版本`rc`: 即 `Release candiate`

### 4. `lock`文件

实际开发中，经常会因为各种依赖不一致而产生奇怪的问题，或者在某些场景下，我们不希望依赖被更新，建议在开发中使用 `package-lock.json`。

锁定依赖版本意味着在我们不手动执行更新的情况下，每次安装依赖都会安装固定版本。保证整个团队使用版本号一致的依赖。

> 使用 package-lock.json 要确保npm的版本在5.6以上，因为在5.0 - 5.6中间，对 package-lock.json的处理逻辑进行过几次更新，5.6版本后处理逻辑逐渐稳定。

### 5. 剖析`npm install`运行原理

![20201111165231](https://raw.githubusercontent.com/aaaaaAndy/picture/main/images/20210129140117.jpg)

`npm install` 大概会经过上面的几个流程，这一章就来讲一讲各个流程的实现细节、发展以及为何要这样实现。

#### 5.1 嵌套结构

在 `npm` 的早期版本， `npm` 处理依赖的方式简单粗暴，以递归的形式，严格按照 `package.json` 结构以及子依赖包的 `package.json` 结构将依赖安装到他们各自的 `node_modules` 中。直到有子依赖包不在依赖其他模块。

这样的方式优点很明显， `node_modules` 的结构和 `package.json` 结构一一对应，层级结构明显，并且保证了每次安装目录结构都是相同的。

但是，试想一下，如果你依赖的模块非常之多，你的 `node_modules` 将非常庞大，嵌套层级非常之深：

- 在不同层级的依赖中，可能引用了同一个模块，导致大量冗余。
- 在 `Windows` 系统中，文件路径最大长度为260个字符，嵌套层级过深可能导致不可预知的问题。

#### 5.2 扁平结构

为了解决以上问题，`NPM` 在 `3.x` 版本做了一次较大更新。其将早期的嵌套结构改为扁平结构：

- 安装模块时，不管其是直接依赖还是子依赖的依赖，优先将其安装在 `node_modules` 根目录。
- 当安装到相同模块时，判断已安装的模块版本是否符合新模块的版本范围，如果符合则跳过，不符合则在当前模块的 `node_modules` 下安装该模块。

对应的，如果我们在项目代码中引用了一个模块，模块查找流程如下：

- 在当前模块路径下搜索
- 在当前模块 `node_modules` 路径下搜素
- 在上级模块的 `node_modules` 路径下搜索
- ...
- 直到搜索到全局路径中的 `node_modules`

所以 `npm 3.x` 版本并未完全解决老版本的模块冗余问题，甚至还会带来新的问题。

试想一下，你的APP假设没有依赖 `base64-js@1.0.1` 版本，而你同时依赖了依赖不同 `base64-js` 版本的 `buffer` 和 `buffer2`。由于在执行 `npm install` 的时候，按照 `package.json` 里依赖的顺序依次解析，则 `buffer` 和 `buffer2` 在  `package.json` 的放置顺序则决定了 `node_modules` 的依赖结构：

#### 5.3 `lock`文件

为了解决 `npm install` 的不确定性问题，在 `npm 5.x` 版本新增了 `package-lock.json` 文件，而安装方式还沿用了 `npm 3.x` 的扁平化的方式。

`package-lock.json` 的作用是锁定依赖结构，即只要你目录下有 `package-lock.json` 文件，那么你每次执行 `npm install` 后生成的 `node_modules` 目录结构一定是完全相同的。

### 6. 整体流程

检查 `.npmrc` 文件：优先级为：项目级的 `.npmrc` 文件 > 用户级的 `.npmrc` 文件> 全局级的 `.npmrc` 文件 > npm 内置的 `.npmrc` 文件

检查项目中有无 `lock` 文件。

无 `lock` 文件：

- 从 `npm` 远程仓库获取包信息

- 根据 

    ```
    package.json
    ```

     构建依赖树，构建过程：

    - 构建依赖树时，不管其是直接依赖还是子依赖的依赖，优先将其放置在 `node_modules` 根目录。
    - 当遇到相同模块时，判断已放置在依赖树的模块版本是否符合新模块的版本范围，如果符合则跳过，不符合则在当前模块的 `node_modules` 下放置该模块。
    - 注意这一步只是确定逻辑上的依赖树，并非真正的安装，后面会根据这个依赖结构去下载或拿到缓存中的依赖包

- 在缓存中依次查找依赖树中的每个包

    - 不存在缓存：
        - 从 `npm` 远程仓库下载包
        - 校验包的完整性
        - 校验不通过：
            - 重新下载
        - 校验通过：
            - 将下载的包复制到 `npm` 缓存目录
            - 将下载的包按照依赖结构解压到 `node_modules`
    - 存在缓存：将缓存按照依赖结构解压到 `node_modules`

- 将包解压到 `node_modules`

- 生成 `lock` 文件

有 `lock` 文件：

- 检查 `package.json` 中的依赖版本是否和 `package-lock.json` 中的依赖有冲突。
- 如果没有冲突，直接跳过获取包信息、构建依赖树过程，开始在缓存中查找包信息，后续过程相同

### 7. `yarn`

`yarn` 是在 `2016` 年发布的，那时 `npm` 还处于 `V3` 时期，那时候还没有 `package-lock.json` 文件，就像上面我们提到的：不稳定性、安装速度慢等缺点经常会受到广大开发者吐槽。此时，`yarn` 诞生。

上面是官网提到的 `yarn` 的优点，在那个时候还是非常吸引人的。当然，后来 `npm` 也意识到了自己的问题，进行了很多次优化，在后面的优化（`lock`文件、缓存、默认-s...）中，我们多多少少能看到 `yarn` 的影子，可见 `yarn` 的设计还是非常优秀的。

`yarn` 也是采用的是 `npm v3` 的扁平结构来管理依赖，安装依赖后默认会生成一个 `yarn.lock` 文件，还是上面的依赖关系，我们看看 `yarn.lock` 的结构。

可见其和 `package-lock.json` 文件还是比较类似的，还有一些区别就是：

- `package-lock.json` 使用的是 `json` 格式，`yarn.lock` 使用的是一种自定义格式
- `yarn.lock` 中子依赖的版本号不是固定的，意味着单独又一个 `yarn.lock` 确定不了 `node_modules` 目录结构，还需要和 `package.json` 文件进行配合。而 `package-lock.json` 只需要一个文件即可确定。



## 